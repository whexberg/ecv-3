
/* !!! This is code generated by Prisma. Do not edit directly. !!! */
/* eslint-disable */
// biome-ignore-all lint: generated file
// @ts-nocheck 
/*
 * This file exports the `EventRecurrenceLink` model and its related types.
 *
 * ðŸŸ¢ You can import this file directly.
 */
import type * as runtime from "@prisma/client/runtime/client"
import type * as $Enums from "../enums"
import type * as Prisma from "../internal/prismaNamespace"

/**
 * Model EventRecurrenceLink
 * 
 */
export type EventRecurrenceLinkModel = runtime.Types.Result.DefaultSelection<Prisma.$EventRecurrenceLinkPayload>

export type AggregateEventRecurrenceLink = {
  _count: EventRecurrenceLinkCountAggregateOutputType | null
  _min: EventRecurrenceLinkMinAggregateOutputType | null
  _max: EventRecurrenceLinkMaxAggregateOutputType | null
}

export type EventRecurrenceLinkMinAggregateOutputType = {
  event_id: string | null
  recurrence_id: string | null
}

export type EventRecurrenceLinkMaxAggregateOutputType = {
  event_id: string | null
  recurrence_id: string | null
}

export type EventRecurrenceLinkCountAggregateOutputType = {
  event_id: number
  recurrence_id: number
  _all: number
}


export type EventRecurrenceLinkMinAggregateInputType = {
  event_id?: true
  recurrence_id?: true
}

export type EventRecurrenceLinkMaxAggregateInputType = {
  event_id?: true
  recurrence_id?: true
}

export type EventRecurrenceLinkCountAggregateInputType = {
  event_id?: true
  recurrence_id?: true
  _all?: true
}

export type EventRecurrenceLinkAggregateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which EventRecurrenceLink to aggregate.
   */
  where?: Prisma.EventRecurrenceLinkWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of EventRecurrenceLinks to fetch.
   */
  orderBy?: Prisma.EventRecurrenceLinkOrderByWithRelationInput | Prisma.EventRecurrenceLinkOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the start position
   */
  cursor?: Prisma.EventRecurrenceLinkWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` EventRecurrenceLinks from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` EventRecurrenceLinks.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Count returned EventRecurrenceLinks
  **/
  _count?: true | EventRecurrenceLinkCountAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the minimum value
  **/
  _min?: EventRecurrenceLinkMinAggregateInputType
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
   * 
   * Select which fields to find the maximum value
  **/
  _max?: EventRecurrenceLinkMaxAggregateInputType
}

export type GetEventRecurrenceLinkAggregateType<T extends EventRecurrenceLinkAggregateArgs> = {
      [P in keyof T & keyof AggregateEventRecurrenceLink]: P extends '_count' | 'count'
    ? T[P] extends true
      ? number
      : Prisma.GetScalarType<T[P], AggregateEventRecurrenceLink[P]>
    : Prisma.GetScalarType<T[P], AggregateEventRecurrenceLink[P]>
}




export type EventRecurrenceLinkGroupByArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  where?: Prisma.EventRecurrenceLinkWhereInput
  orderBy?: Prisma.EventRecurrenceLinkOrderByWithAggregationInput | Prisma.EventRecurrenceLinkOrderByWithAggregationInput[]
  by: Prisma.EventRecurrenceLinkScalarFieldEnum[] | Prisma.EventRecurrenceLinkScalarFieldEnum
  having?: Prisma.EventRecurrenceLinkScalarWhereWithAggregatesInput
  take?: number
  skip?: number
  _count?: EventRecurrenceLinkCountAggregateInputType | true
  _min?: EventRecurrenceLinkMinAggregateInputType
  _max?: EventRecurrenceLinkMaxAggregateInputType
}

export type EventRecurrenceLinkGroupByOutputType = {
  event_id: string
  recurrence_id: string
  _count: EventRecurrenceLinkCountAggregateOutputType | null
  _min: EventRecurrenceLinkMinAggregateOutputType | null
  _max: EventRecurrenceLinkMaxAggregateOutputType | null
}

type GetEventRecurrenceLinkGroupByPayload<T extends EventRecurrenceLinkGroupByArgs> = Prisma.PrismaPromise<
  Array<
    Prisma.PickEnumerable<EventRecurrenceLinkGroupByOutputType, T['by']> &
      {
        [P in ((keyof T) & (keyof EventRecurrenceLinkGroupByOutputType))]: P extends '_count'
          ? T[P] extends boolean
            ? number
            : Prisma.GetScalarType<T[P], EventRecurrenceLinkGroupByOutputType[P]>
          : Prisma.GetScalarType<T[P], EventRecurrenceLinkGroupByOutputType[P]>
      }
    >
  >



export type EventRecurrenceLinkWhereInput = {
  AND?: Prisma.EventRecurrenceLinkWhereInput | Prisma.EventRecurrenceLinkWhereInput[]
  OR?: Prisma.EventRecurrenceLinkWhereInput[]
  NOT?: Prisma.EventRecurrenceLinkWhereInput | Prisma.EventRecurrenceLinkWhereInput[]
  event_id?: Prisma.StringFilter<"EventRecurrenceLink"> | string
  recurrence_id?: Prisma.StringFilter<"EventRecurrenceLink"> | string
  event?: Prisma.XOR<Prisma.EventScalarRelationFilter, Prisma.EventWhereInput>
  recurrence?: Prisma.XOR<Prisma.EventRecurrenceScalarRelationFilter, Prisma.EventRecurrenceWhereInput>
}

export type EventRecurrenceLinkOrderByWithRelationInput = {
  event_id?: Prisma.SortOrder
  recurrence_id?: Prisma.SortOrder
  event?: Prisma.EventOrderByWithRelationInput
  recurrence?: Prisma.EventRecurrenceOrderByWithRelationInput
}

export type EventRecurrenceLinkWhereUniqueInput = Prisma.AtLeast<{
  event_id_recurrence_id?: Prisma.EventRecurrenceLinkEvent_idRecurrence_idCompoundUniqueInput
  AND?: Prisma.EventRecurrenceLinkWhereInput | Prisma.EventRecurrenceLinkWhereInput[]
  OR?: Prisma.EventRecurrenceLinkWhereInput[]
  NOT?: Prisma.EventRecurrenceLinkWhereInput | Prisma.EventRecurrenceLinkWhereInput[]
  event_id?: Prisma.StringFilter<"EventRecurrenceLink"> | string
  recurrence_id?: Prisma.StringFilter<"EventRecurrenceLink"> | string
  event?: Prisma.XOR<Prisma.EventScalarRelationFilter, Prisma.EventWhereInput>
  recurrence?: Prisma.XOR<Prisma.EventRecurrenceScalarRelationFilter, Prisma.EventRecurrenceWhereInput>
}, "event_id_recurrence_id">

export type EventRecurrenceLinkOrderByWithAggregationInput = {
  event_id?: Prisma.SortOrder
  recurrence_id?: Prisma.SortOrder
  _count?: Prisma.EventRecurrenceLinkCountOrderByAggregateInput
  _max?: Prisma.EventRecurrenceLinkMaxOrderByAggregateInput
  _min?: Prisma.EventRecurrenceLinkMinOrderByAggregateInput
}

export type EventRecurrenceLinkScalarWhereWithAggregatesInput = {
  AND?: Prisma.EventRecurrenceLinkScalarWhereWithAggregatesInput | Prisma.EventRecurrenceLinkScalarWhereWithAggregatesInput[]
  OR?: Prisma.EventRecurrenceLinkScalarWhereWithAggregatesInput[]
  NOT?: Prisma.EventRecurrenceLinkScalarWhereWithAggregatesInput | Prisma.EventRecurrenceLinkScalarWhereWithAggregatesInput[]
  event_id?: Prisma.StringWithAggregatesFilter<"EventRecurrenceLink"> | string
  recurrence_id?: Prisma.StringWithAggregatesFilter<"EventRecurrenceLink"> | string
}

export type EventRecurrenceLinkCreateInput = {
  event: Prisma.EventCreateNestedOneWithoutRecurrencesInput
  recurrence: Prisma.EventRecurrenceCreateNestedOneWithoutEventsInput
}

export type EventRecurrenceLinkUncheckedCreateInput = {
  event_id: string
  recurrence_id: string
}

export type EventRecurrenceLinkUpdateInput = {
  event?: Prisma.EventUpdateOneRequiredWithoutRecurrencesNestedInput
  recurrence?: Prisma.EventRecurrenceUpdateOneRequiredWithoutEventsNestedInput
}

export type EventRecurrenceLinkUncheckedUpdateInput = {
  event_id?: Prisma.StringFieldUpdateOperationsInput | string
  recurrence_id?: Prisma.StringFieldUpdateOperationsInput | string
}

export type EventRecurrenceLinkCreateManyInput = {
  event_id: string
  recurrence_id: string
}

export type EventRecurrenceLinkUpdateManyMutationInput = {

}

export type EventRecurrenceLinkUncheckedUpdateManyInput = {
  event_id?: Prisma.StringFieldUpdateOperationsInput | string
  recurrence_id?: Prisma.StringFieldUpdateOperationsInput | string
}

export type EventRecurrenceLinkListRelationFilter = {
  every?: Prisma.EventRecurrenceLinkWhereInput
  some?: Prisma.EventRecurrenceLinkWhereInput
  none?: Prisma.EventRecurrenceLinkWhereInput
}

export type EventRecurrenceLinkOrderByRelationAggregateInput = {
  _count?: Prisma.SortOrder
}

export type EventRecurrenceLinkEvent_idRecurrence_idCompoundUniqueInput = {
  event_id: string
  recurrence_id: string
}

export type EventRecurrenceLinkCountOrderByAggregateInput = {
  event_id?: Prisma.SortOrder
  recurrence_id?: Prisma.SortOrder
}

export type EventRecurrenceLinkMaxOrderByAggregateInput = {
  event_id?: Prisma.SortOrder
  recurrence_id?: Prisma.SortOrder
}

export type EventRecurrenceLinkMinOrderByAggregateInput = {
  event_id?: Prisma.SortOrder
  recurrence_id?: Prisma.SortOrder
}

export type EventRecurrenceLinkCreateNestedManyWithoutEventInput = {
  create?: Prisma.XOR<Prisma.EventRecurrenceLinkCreateWithoutEventInput, Prisma.EventRecurrenceLinkUncheckedCreateWithoutEventInput> | Prisma.EventRecurrenceLinkCreateWithoutEventInput[] | Prisma.EventRecurrenceLinkUncheckedCreateWithoutEventInput[]
  connectOrCreate?: Prisma.EventRecurrenceLinkCreateOrConnectWithoutEventInput | Prisma.EventRecurrenceLinkCreateOrConnectWithoutEventInput[]
  createMany?: Prisma.EventRecurrenceLinkCreateManyEventInputEnvelope
  connect?: Prisma.EventRecurrenceLinkWhereUniqueInput | Prisma.EventRecurrenceLinkWhereUniqueInput[]
}

export type EventRecurrenceLinkUncheckedCreateNestedManyWithoutEventInput = {
  create?: Prisma.XOR<Prisma.EventRecurrenceLinkCreateWithoutEventInput, Prisma.EventRecurrenceLinkUncheckedCreateWithoutEventInput> | Prisma.EventRecurrenceLinkCreateWithoutEventInput[] | Prisma.EventRecurrenceLinkUncheckedCreateWithoutEventInput[]
  connectOrCreate?: Prisma.EventRecurrenceLinkCreateOrConnectWithoutEventInput | Prisma.EventRecurrenceLinkCreateOrConnectWithoutEventInput[]
  createMany?: Prisma.EventRecurrenceLinkCreateManyEventInputEnvelope
  connect?: Prisma.EventRecurrenceLinkWhereUniqueInput | Prisma.EventRecurrenceLinkWhereUniqueInput[]
}

export type EventRecurrenceLinkUpdateManyWithoutEventNestedInput = {
  create?: Prisma.XOR<Prisma.EventRecurrenceLinkCreateWithoutEventInput, Prisma.EventRecurrenceLinkUncheckedCreateWithoutEventInput> | Prisma.EventRecurrenceLinkCreateWithoutEventInput[] | Prisma.EventRecurrenceLinkUncheckedCreateWithoutEventInput[]
  connectOrCreate?: Prisma.EventRecurrenceLinkCreateOrConnectWithoutEventInput | Prisma.EventRecurrenceLinkCreateOrConnectWithoutEventInput[]
  upsert?: Prisma.EventRecurrenceLinkUpsertWithWhereUniqueWithoutEventInput | Prisma.EventRecurrenceLinkUpsertWithWhereUniqueWithoutEventInput[]
  createMany?: Prisma.EventRecurrenceLinkCreateManyEventInputEnvelope
  set?: Prisma.EventRecurrenceLinkWhereUniqueInput | Prisma.EventRecurrenceLinkWhereUniqueInput[]
  disconnect?: Prisma.EventRecurrenceLinkWhereUniqueInput | Prisma.EventRecurrenceLinkWhereUniqueInput[]
  delete?: Prisma.EventRecurrenceLinkWhereUniqueInput | Prisma.EventRecurrenceLinkWhereUniqueInput[]
  connect?: Prisma.EventRecurrenceLinkWhereUniqueInput | Prisma.EventRecurrenceLinkWhereUniqueInput[]
  update?: Prisma.EventRecurrenceLinkUpdateWithWhereUniqueWithoutEventInput | Prisma.EventRecurrenceLinkUpdateWithWhereUniqueWithoutEventInput[]
  updateMany?: Prisma.EventRecurrenceLinkUpdateManyWithWhereWithoutEventInput | Prisma.EventRecurrenceLinkUpdateManyWithWhereWithoutEventInput[]
  deleteMany?: Prisma.EventRecurrenceLinkScalarWhereInput | Prisma.EventRecurrenceLinkScalarWhereInput[]
}

export type EventRecurrenceLinkUncheckedUpdateManyWithoutEventNestedInput = {
  create?: Prisma.XOR<Prisma.EventRecurrenceLinkCreateWithoutEventInput, Prisma.EventRecurrenceLinkUncheckedCreateWithoutEventInput> | Prisma.EventRecurrenceLinkCreateWithoutEventInput[] | Prisma.EventRecurrenceLinkUncheckedCreateWithoutEventInput[]
  connectOrCreate?: Prisma.EventRecurrenceLinkCreateOrConnectWithoutEventInput | Prisma.EventRecurrenceLinkCreateOrConnectWithoutEventInput[]
  upsert?: Prisma.EventRecurrenceLinkUpsertWithWhereUniqueWithoutEventInput | Prisma.EventRecurrenceLinkUpsertWithWhereUniqueWithoutEventInput[]
  createMany?: Prisma.EventRecurrenceLinkCreateManyEventInputEnvelope
  set?: Prisma.EventRecurrenceLinkWhereUniqueInput | Prisma.EventRecurrenceLinkWhereUniqueInput[]
  disconnect?: Prisma.EventRecurrenceLinkWhereUniqueInput | Prisma.EventRecurrenceLinkWhereUniqueInput[]
  delete?: Prisma.EventRecurrenceLinkWhereUniqueInput | Prisma.EventRecurrenceLinkWhereUniqueInput[]
  connect?: Prisma.EventRecurrenceLinkWhereUniqueInput | Prisma.EventRecurrenceLinkWhereUniqueInput[]
  update?: Prisma.EventRecurrenceLinkUpdateWithWhereUniqueWithoutEventInput | Prisma.EventRecurrenceLinkUpdateWithWhereUniqueWithoutEventInput[]
  updateMany?: Prisma.EventRecurrenceLinkUpdateManyWithWhereWithoutEventInput | Prisma.EventRecurrenceLinkUpdateManyWithWhereWithoutEventInput[]
  deleteMany?: Prisma.EventRecurrenceLinkScalarWhereInput | Prisma.EventRecurrenceLinkScalarWhereInput[]
}

export type EventRecurrenceLinkCreateNestedManyWithoutRecurrenceInput = {
  create?: Prisma.XOR<Prisma.EventRecurrenceLinkCreateWithoutRecurrenceInput, Prisma.EventRecurrenceLinkUncheckedCreateWithoutRecurrenceInput> | Prisma.EventRecurrenceLinkCreateWithoutRecurrenceInput[] | Prisma.EventRecurrenceLinkUncheckedCreateWithoutRecurrenceInput[]
  connectOrCreate?: Prisma.EventRecurrenceLinkCreateOrConnectWithoutRecurrenceInput | Prisma.EventRecurrenceLinkCreateOrConnectWithoutRecurrenceInput[]
  createMany?: Prisma.EventRecurrenceLinkCreateManyRecurrenceInputEnvelope
  connect?: Prisma.EventRecurrenceLinkWhereUniqueInput | Prisma.EventRecurrenceLinkWhereUniqueInput[]
}

export type EventRecurrenceLinkUncheckedCreateNestedManyWithoutRecurrenceInput = {
  create?: Prisma.XOR<Prisma.EventRecurrenceLinkCreateWithoutRecurrenceInput, Prisma.EventRecurrenceLinkUncheckedCreateWithoutRecurrenceInput> | Prisma.EventRecurrenceLinkCreateWithoutRecurrenceInput[] | Prisma.EventRecurrenceLinkUncheckedCreateWithoutRecurrenceInput[]
  connectOrCreate?: Prisma.EventRecurrenceLinkCreateOrConnectWithoutRecurrenceInput | Prisma.EventRecurrenceLinkCreateOrConnectWithoutRecurrenceInput[]
  createMany?: Prisma.EventRecurrenceLinkCreateManyRecurrenceInputEnvelope
  connect?: Prisma.EventRecurrenceLinkWhereUniqueInput | Prisma.EventRecurrenceLinkWhereUniqueInput[]
}

export type EventRecurrenceLinkUpdateManyWithoutRecurrenceNestedInput = {
  create?: Prisma.XOR<Prisma.EventRecurrenceLinkCreateWithoutRecurrenceInput, Prisma.EventRecurrenceLinkUncheckedCreateWithoutRecurrenceInput> | Prisma.EventRecurrenceLinkCreateWithoutRecurrenceInput[] | Prisma.EventRecurrenceLinkUncheckedCreateWithoutRecurrenceInput[]
  connectOrCreate?: Prisma.EventRecurrenceLinkCreateOrConnectWithoutRecurrenceInput | Prisma.EventRecurrenceLinkCreateOrConnectWithoutRecurrenceInput[]
  upsert?: Prisma.EventRecurrenceLinkUpsertWithWhereUniqueWithoutRecurrenceInput | Prisma.EventRecurrenceLinkUpsertWithWhereUniqueWithoutRecurrenceInput[]
  createMany?: Prisma.EventRecurrenceLinkCreateManyRecurrenceInputEnvelope
  set?: Prisma.EventRecurrenceLinkWhereUniqueInput | Prisma.EventRecurrenceLinkWhereUniqueInput[]
  disconnect?: Prisma.EventRecurrenceLinkWhereUniqueInput | Prisma.EventRecurrenceLinkWhereUniqueInput[]
  delete?: Prisma.EventRecurrenceLinkWhereUniqueInput | Prisma.EventRecurrenceLinkWhereUniqueInput[]
  connect?: Prisma.EventRecurrenceLinkWhereUniqueInput | Prisma.EventRecurrenceLinkWhereUniqueInput[]
  update?: Prisma.EventRecurrenceLinkUpdateWithWhereUniqueWithoutRecurrenceInput | Prisma.EventRecurrenceLinkUpdateWithWhereUniqueWithoutRecurrenceInput[]
  updateMany?: Prisma.EventRecurrenceLinkUpdateManyWithWhereWithoutRecurrenceInput | Prisma.EventRecurrenceLinkUpdateManyWithWhereWithoutRecurrenceInput[]
  deleteMany?: Prisma.EventRecurrenceLinkScalarWhereInput | Prisma.EventRecurrenceLinkScalarWhereInput[]
}

export type EventRecurrenceLinkUncheckedUpdateManyWithoutRecurrenceNestedInput = {
  create?: Prisma.XOR<Prisma.EventRecurrenceLinkCreateWithoutRecurrenceInput, Prisma.EventRecurrenceLinkUncheckedCreateWithoutRecurrenceInput> | Prisma.EventRecurrenceLinkCreateWithoutRecurrenceInput[] | Prisma.EventRecurrenceLinkUncheckedCreateWithoutRecurrenceInput[]
  connectOrCreate?: Prisma.EventRecurrenceLinkCreateOrConnectWithoutRecurrenceInput | Prisma.EventRecurrenceLinkCreateOrConnectWithoutRecurrenceInput[]
  upsert?: Prisma.EventRecurrenceLinkUpsertWithWhereUniqueWithoutRecurrenceInput | Prisma.EventRecurrenceLinkUpsertWithWhereUniqueWithoutRecurrenceInput[]
  createMany?: Prisma.EventRecurrenceLinkCreateManyRecurrenceInputEnvelope
  set?: Prisma.EventRecurrenceLinkWhereUniqueInput | Prisma.EventRecurrenceLinkWhereUniqueInput[]
  disconnect?: Prisma.EventRecurrenceLinkWhereUniqueInput | Prisma.EventRecurrenceLinkWhereUniqueInput[]
  delete?: Prisma.EventRecurrenceLinkWhereUniqueInput | Prisma.EventRecurrenceLinkWhereUniqueInput[]
  connect?: Prisma.EventRecurrenceLinkWhereUniqueInput | Prisma.EventRecurrenceLinkWhereUniqueInput[]
  update?: Prisma.EventRecurrenceLinkUpdateWithWhereUniqueWithoutRecurrenceInput | Prisma.EventRecurrenceLinkUpdateWithWhereUniqueWithoutRecurrenceInput[]
  updateMany?: Prisma.EventRecurrenceLinkUpdateManyWithWhereWithoutRecurrenceInput | Prisma.EventRecurrenceLinkUpdateManyWithWhereWithoutRecurrenceInput[]
  deleteMany?: Prisma.EventRecurrenceLinkScalarWhereInput | Prisma.EventRecurrenceLinkScalarWhereInput[]
}

export type EventRecurrenceLinkCreateWithoutEventInput = {
  recurrence: Prisma.EventRecurrenceCreateNestedOneWithoutEventsInput
}

export type EventRecurrenceLinkUncheckedCreateWithoutEventInput = {
  recurrence_id: string
}

export type EventRecurrenceLinkCreateOrConnectWithoutEventInput = {
  where: Prisma.EventRecurrenceLinkWhereUniqueInput
  create: Prisma.XOR<Prisma.EventRecurrenceLinkCreateWithoutEventInput, Prisma.EventRecurrenceLinkUncheckedCreateWithoutEventInput>
}

export type EventRecurrenceLinkCreateManyEventInputEnvelope = {
  data: Prisma.EventRecurrenceLinkCreateManyEventInput | Prisma.EventRecurrenceLinkCreateManyEventInput[]
}

export type EventRecurrenceLinkUpsertWithWhereUniqueWithoutEventInput = {
  where: Prisma.EventRecurrenceLinkWhereUniqueInput
  update: Prisma.XOR<Prisma.EventRecurrenceLinkUpdateWithoutEventInput, Prisma.EventRecurrenceLinkUncheckedUpdateWithoutEventInput>
  create: Prisma.XOR<Prisma.EventRecurrenceLinkCreateWithoutEventInput, Prisma.EventRecurrenceLinkUncheckedCreateWithoutEventInput>
}

export type EventRecurrenceLinkUpdateWithWhereUniqueWithoutEventInput = {
  where: Prisma.EventRecurrenceLinkWhereUniqueInput
  data: Prisma.XOR<Prisma.EventRecurrenceLinkUpdateWithoutEventInput, Prisma.EventRecurrenceLinkUncheckedUpdateWithoutEventInput>
}

export type EventRecurrenceLinkUpdateManyWithWhereWithoutEventInput = {
  where: Prisma.EventRecurrenceLinkScalarWhereInput
  data: Prisma.XOR<Prisma.EventRecurrenceLinkUpdateManyMutationInput, Prisma.EventRecurrenceLinkUncheckedUpdateManyWithoutEventInput>
}

export type EventRecurrenceLinkScalarWhereInput = {
  AND?: Prisma.EventRecurrenceLinkScalarWhereInput | Prisma.EventRecurrenceLinkScalarWhereInput[]
  OR?: Prisma.EventRecurrenceLinkScalarWhereInput[]
  NOT?: Prisma.EventRecurrenceLinkScalarWhereInput | Prisma.EventRecurrenceLinkScalarWhereInput[]
  event_id?: Prisma.StringFilter<"EventRecurrenceLink"> | string
  recurrence_id?: Prisma.StringFilter<"EventRecurrenceLink"> | string
}

export type EventRecurrenceLinkCreateWithoutRecurrenceInput = {
  event: Prisma.EventCreateNestedOneWithoutRecurrencesInput
}

export type EventRecurrenceLinkUncheckedCreateWithoutRecurrenceInput = {
  event_id: string
}

export type EventRecurrenceLinkCreateOrConnectWithoutRecurrenceInput = {
  where: Prisma.EventRecurrenceLinkWhereUniqueInput
  create: Prisma.XOR<Prisma.EventRecurrenceLinkCreateWithoutRecurrenceInput, Prisma.EventRecurrenceLinkUncheckedCreateWithoutRecurrenceInput>
}

export type EventRecurrenceLinkCreateManyRecurrenceInputEnvelope = {
  data: Prisma.EventRecurrenceLinkCreateManyRecurrenceInput | Prisma.EventRecurrenceLinkCreateManyRecurrenceInput[]
}

export type EventRecurrenceLinkUpsertWithWhereUniqueWithoutRecurrenceInput = {
  where: Prisma.EventRecurrenceLinkWhereUniqueInput
  update: Prisma.XOR<Prisma.EventRecurrenceLinkUpdateWithoutRecurrenceInput, Prisma.EventRecurrenceLinkUncheckedUpdateWithoutRecurrenceInput>
  create: Prisma.XOR<Prisma.EventRecurrenceLinkCreateWithoutRecurrenceInput, Prisma.EventRecurrenceLinkUncheckedCreateWithoutRecurrenceInput>
}

export type EventRecurrenceLinkUpdateWithWhereUniqueWithoutRecurrenceInput = {
  where: Prisma.EventRecurrenceLinkWhereUniqueInput
  data: Prisma.XOR<Prisma.EventRecurrenceLinkUpdateWithoutRecurrenceInput, Prisma.EventRecurrenceLinkUncheckedUpdateWithoutRecurrenceInput>
}

export type EventRecurrenceLinkUpdateManyWithWhereWithoutRecurrenceInput = {
  where: Prisma.EventRecurrenceLinkScalarWhereInput
  data: Prisma.XOR<Prisma.EventRecurrenceLinkUpdateManyMutationInput, Prisma.EventRecurrenceLinkUncheckedUpdateManyWithoutRecurrenceInput>
}

export type EventRecurrenceLinkCreateManyEventInput = {
  recurrence_id: string
}

export type EventRecurrenceLinkUpdateWithoutEventInput = {
  recurrence?: Prisma.EventRecurrenceUpdateOneRequiredWithoutEventsNestedInput
}

export type EventRecurrenceLinkUncheckedUpdateWithoutEventInput = {
  recurrence_id?: Prisma.StringFieldUpdateOperationsInput | string
}

export type EventRecurrenceLinkUncheckedUpdateManyWithoutEventInput = {
  recurrence_id?: Prisma.StringFieldUpdateOperationsInput | string
}

export type EventRecurrenceLinkCreateManyRecurrenceInput = {
  event_id: string
}

export type EventRecurrenceLinkUpdateWithoutRecurrenceInput = {
  event?: Prisma.EventUpdateOneRequiredWithoutRecurrencesNestedInput
}

export type EventRecurrenceLinkUncheckedUpdateWithoutRecurrenceInput = {
  event_id?: Prisma.StringFieldUpdateOperationsInput | string
}

export type EventRecurrenceLinkUncheckedUpdateManyWithoutRecurrenceInput = {
  event_id?: Prisma.StringFieldUpdateOperationsInput | string
}



export type EventRecurrenceLinkSelect<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  event_id?: boolean
  recurrence_id?: boolean
  event?: boolean | Prisma.EventDefaultArgs<ExtArgs>
  recurrence?: boolean | Prisma.EventRecurrenceDefaultArgs<ExtArgs>
}, ExtArgs["result"]["eventRecurrenceLink"]>

export type EventRecurrenceLinkSelectCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  event_id?: boolean
  recurrence_id?: boolean
  event?: boolean | Prisma.EventDefaultArgs<ExtArgs>
  recurrence?: boolean | Prisma.EventRecurrenceDefaultArgs<ExtArgs>
}, ExtArgs["result"]["eventRecurrenceLink"]>

export type EventRecurrenceLinkSelectUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetSelect<{
  event_id?: boolean
  recurrence_id?: boolean
  event?: boolean | Prisma.EventDefaultArgs<ExtArgs>
  recurrence?: boolean | Prisma.EventRecurrenceDefaultArgs<ExtArgs>
}, ExtArgs["result"]["eventRecurrenceLink"]>

export type EventRecurrenceLinkSelectScalar = {
  event_id?: boolean
  recurrence_id?: boolean
}

export type EventRecurrenceLinkOmit<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = runtime.Types.Extensions.GetOmit<"event_id" | "recurrence_id", ExtArgs["result"]["eventRecurrenceLink"]>
export type EventRecurrenceLinkInclude<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  event?: boolean | Prisma.EventDefaultArgs<ExtArgs>
  recurrence?: boolean | Prisma.EventRecurrenceDefaultArgs<ExtArgs>
}
export type EventRecurrenceLinkIncludeCreateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  event?: boolean | Prisma.EventDefaultArgs<ExtArgs>
  recurrence?: boolean | Prisma.EventRecurrenceDefaultArgs<ExtArgs>
}
export type EventRecurrenceLinkIncludeUpdateManyAndReturn<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  event?: boolean | Prisma.EventDefaultArgs<ExtArgs>
  recurrence?: boolean | Prisma.EventRecurrenceDefaultArgs<ExtArgs>
}

export type $EventRecurrenceLinkPayload<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  name: "EventRecurrenceLink"
  objects: {
    event: Prisma.$EventPayload<ExtArgs>
    recurrence: Prisma.$EventRecurrencePayload<ExtArgs>
  }
  scalars: runtime.Types.Extensions.GetPayloadResult<{
    event_id: string
    recurrence_id: string
  }, ExtArgs["result"]["eventRecurrenceLink"]>
  composites: {}
}

export type EventRecurrenceLinkGetPayload<S extends boolean | null | undefined | EventRecurrenceLinkDefaultArgs> = runtime.Types.Result.GetResult<Prisma.$EventRecurrenceLinkPayload, S>

export type EventRecurrenceLinkCountArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> =
  Omit<EventRecurrenceLinkFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
    select?: EventRecurrenceLinkCountAggregateInputType | true
  }

export interface EventRecurrenceLinkDelegate<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EventRecurrenceLink'], meta: { name: 'EventRecurrenceLink' } }
  /**
   * Find zero or one EventRecurrenceLink that matches the filter.
   * @param {EventRecurrenceLinkFindUniqueArgs} args - Arguments to find a EventRecurrenceLink
   * @example
   * // Get one EventRecurrenceLink
   * const eventRecurrenceLink = await prisma.eventRecurrenceLink.findUnique({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUnique<T extends EventRecurrenceLinkFindUniqueArgs>(args: Prisma.SelectSubset<T, EventRecurrenceLinkFindUniqueArgs<ExtArgs>>): Prisma.Prisma__EventRecurrenceLinkClient<runtime.Types.Result.GetResult<Prisma.$EventRecurrenceLinkPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find one EventRecurrenceLink that matches the filter or throw an error with `error.code='P2025'`
   * if no matches were found.
   * @param {EventRecurrenceLinkFindUniqueOrThrowArgs} args - Arguments to find a EventRecurrenceLink
   * @example
   * // Get one EventRecurrenceLink
   * const eventRecurrenceLink = await prisma.eventRecurrenceLink.findUniqueOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findUniqueOrThrow<T extends EventRecurrenceLinkFindUniqueOrThrowArgs>(args: Prisma.SelectSubset<T, EventRecurrenceLinkFindUniqueOrThrowArgs<ExtArgs>>): Prisma.Prisma__EventRecurrenceLinkClient<runtime.Types.Result.GetResult<Prisma.$EventRecurrenceLinkPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first EventRecurrenceLink that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {EventRecurrenceLinkFindFirstArgs} args - Arguments to find a EventRecurrenceLink
   * @example
   * // Get one EventRecurrenceLink
   * const eventRecurrenceLink = await prisma.eventRecurrenceLink.findFirst({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirst<T extends EventRecurrenceLinkFindFirstArgs>(args?: Prisma.SelectSubset<T, EventRecurrenceLinkFindFirstArgs<ExtArgs>>): Prisma.Prisma__EventRecurrenceLinkClient<runtime.Types.Result.GetResult<Prisma.$EventRecurrenceLinkPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

  /**
   * Find the first EventRecurrenceLink that matches the filter or
   * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {EventRecurrenceLinkFindFirstOrThrowArgs} args - Arguments to find a EventRecurrenceLink
   * @example
   * // Get one EventRecurrenceLink
   * const eventRecurrenceLink = await prisma.eventRecurrenceLink.findFirstOrThrow({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   */
  findFirstOrThrow<T extends EventRecurrenceLinkFindFirstOrThrowArgs>(args?: Prisma.SelectSubset<T, EventRecurrenceLinkFindFirstOrThrowArgs<ExtArgs>>): Prisma.Prisma__EventRecurrenceLinkClient<runtime.Types.Result.GetResult<Prisma.$EventRecurrenceLinkPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Find zero or more EventRecurrenceLinks that matches the filter.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {EventRecurrenceLinkFindManyArgs} args - Arguments to filter and select certain fields only.
   * @example
   * // Get all EventRecurrenceLinks
   * const eventRecurrenceLinks = await prisma.eventRecurrenceLink.findMany()
   * 
   * // Get first 10 EventRecurrenceLinks
   * const eventRecurrenceLinks = await prisma.eventRecurrenceLink.findMany({ take: 10 })
   * 
   * // Only select the `event_id`
   * const eventRecurrenceLinkWithEvent_idOnly = await prisma.eventRecurrenceLink.findMany({ select: { event_id: true } })
   * 
   */
  findMany<T extends EventRecurrenceLinkFindManyArgs>(args?: Prisma.SelectSubset<T, EventRecurrenceLinkFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$EventRecurrenceLinkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

  /**
   * Create a EventRecurrenceLink.
   * @param {EventRecurrenceLinkCreateArgs} args - Arguments to create a EventRecurrenceLink.
   * @example
   * // Create one EventRecurrenceLink
   * const EventRecurrenceLink = await prisma.eventRecurrenceLink.create({
   *   data: {
   *     // ... data to create a EventRecurrenceLink
   *   }
   * })
   * 
   */
  create<T extends EventRecurrenceLinkCreateArgs>(args: Prisma.SelectSubset<T, EventRecurrenceLinkCreateArgs<ExtArgs>>): Prisma.Prisma__EventRecurrenceLinkClient<runtime.Types.Result.GetResult<Prisma.$EventRecurrenceLinkPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Create many EventRecurrenceLinks.
   * @param {EventRecurrenceLinkCreateManyArgs} args - Arguments to create many EventRecurrenceLinks.
   * @example
   * // Create many EventRecurrenceLinks
   * const eventRecurrenceLink = await prisma.eventRecurrenceLink.createMany({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   *     
   */
  createMany<T extends EventRecurrenceLinkCreateManyArgs>(args?: Prisma.SelectSubset<T, EventRecurrenceLinkCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Create many EventRecurrenceLinks and returns the data saved in the database.
   * @param {EventRecurrenceLinkCreateManyAndReturnArgs} args - Arguments to create many EventRecurrenceLinks.
   * @example
   * // Create many EventRecurrenceLinks
   * const eventRecurrenceLink = await prisma.eventRecurrenceLink.createManyAndReturn({
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Create many EventRecurrenceLinks and only return the `event_id`
   * const eventRecurrenceLinkWithEvent_idOnly = await prisma.eventRecurrenceLink.createManyAndReturn({
   *   select: { event_id: true },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  createManyAndReturn<T extends EventRecurrenceLinkCreateManyAndReturnArgs>(args?: Prisma.SelectSubset<T, EventRecurrenceLinkCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$EventRecurrenceLinkPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

  /**
   * Delete a EventRecurrenceLink.
   * @param {EventRecurrenceLinkDeleteArgs} args - Arguments to delete one EventRecurrenceLink.
   * @example
   * // Delete one EventRecurrenceLink
   * const EventRecurrenceLink = await prisma.eventRecurrenceLink.delete({
   *   where: {
   *     // ... filter to delete one EventRecurrenceLink
   *   }
   * })
   * 
   */
  delete<T extends EventRecurrenceLinkDeleteArgs>(args: Prisma.SelectSubset<T, EventRecurrenceLinkDeleteArgs<ExtArgs>>): Prisma.Prisma__EventRecurrenceLinkClient<runtime.Types.Result.GetResult<Prisma.$EventRecurrenceLinkPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Update one EventRecurrenceLink.
   * @param {EventRecurrenceLinkUpdateArgs} args - Arguments to update one EventRecurrenceLink.
   * @example
   * // Update one EventRecurrenceLink
   * const eventRecurrenceLink = await prisma.eventRecurrenceLink.update({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  update<T extends EventRecurrenceLinkUpdateArgs>(args: Prisma.SelectSubset<T, EventRecurrenceLinkUpdateArgs<ExtArgs>>): Prisma.Prisma__EventRecurrenceLinkClient<runtime.Types.Result.GetResult<Prisma.$EventRecurrenceLinkPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

  /**
   * Delete zero or more EventRecurrenceLinks.
   * @param {EventRecurrenceLinkDeleteManyArgs} args - Arguments to filter EventRecurrenceLinks to delete.
   * @example
   * // Delete a few EventRecurrenceLinks
   * const { count } = await prisma.eventRecurrenceLink.deleteMany({
   *   where: {
   *     // ... provide filter here
   *   }
   * })
   * 
   */
  deleteMany<T extends EventRecurrenceLinkDeleteManyArgs>(args?: Prisma.SelectSubset<T, EventRecurrenceLinkDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more EventRecurrenceLinks.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {EventRecurrenceLinkUpdateManyArgs} args - Arguments to update one or more rows.
   * @example
   * // Update many EventRecurrenceLinks
   * const eventRecurrenceLink = await prisma.eventRecurrenceLink.updateMany({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: {
   *     // ... provide data here
   *   }
   * })
   * 
   */
  updateMany<T extends EventRecurrenceLinkUpdateManyArgs>(args: Prisma.SelectSubset<T, EventRecurrenceLinkUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<Prisma.BatchPayload>

  /**
   * Update zero or more EventRecurrenceLinks and returns the data updated in the database.
   * @param {EventRecurrenceLinkUpdateManyAndReturnArgs} args - Arguments to update many EventRecurrenceLinks.
   * @example
   * // Update many EventRecurrenceLinks
   * const eventRecurrenceLink = await prisma.eventRecurrenceLink.updateManyAndReturn({
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * 
   * // Update zero or more EventRecurrenceLinks and only return the `event_id`
   * const eventRecurrenceLinkWithEvent_idOnly = await prisma.eventRecurrenceLink.updateManyAndReturn({
   *   select: { event_id: true },
   *   where: {
   *     // ... provide filter here
   *   },
   *   data: [
   *     // ... provide data here
   *   ]
   * })
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * 
   */
  updateManyAndReturn<T extends EventRecurrenceLinkUpdateManyAndReturnArgs>(args: Prisma.SelectSubset<T, EventRecurrenceLinkUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<runtime.Types.Result.GetResult<Prisma.$EventRecurrenceLinkPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

  /**
   * Create or update one EventRecurrenceLink.
   * @param {EventRecurrenceLinkUpsertArgs} args - Arguments to update or create a EventRecurrenceLink.
   * @example
   * // Update or create a EventRecurrenceLink
   * const eventRecurrenceLink = await prisma.eventRecurrenceLink.upsert({
   *   create: {
   *     // ... data to create a EventRecurrenceLink
   *   },
   *   update: {
   *     // ... in case it already exists, update
   *   },
   *   where: {
   *     // ... the filter for the EventRecurrenceLink we want to update
   *   }
   * })
   */
  upsert<T extends EventRecurrenceLinkUpsertArgs>(args: Prisma.SelectSubset<T, EventRecurrenceLinkUpsertArgs<ExtArgs>>): Prisma.Prisma__EventRecurrenceLinkClient<runtime.Types.Result.GetResult<Prisma.$EventRecurrenceLinkPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


  /**
   * Count the number of EventRecurrenceLinks.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {EventRecurrenceLinkCountArgs} args - Arguments to filter EventRecurrenceLinks to count.
   * @example
   * // Count the number of EventRecurrenceLinks
   * const count = await prisma.eventRecurrenceLink.count({
   *   where: {
   *     // ... the filter for the EventRecurrenceLinks we want to count
   *   }
   * })
  **/
  count<T extends EventRecurrenceLinkCountArgs>(
    args?: Prisma.Subset<T, EventRecurrenceLinkCountArgs>,
  ): Prisma.PrismaPromise<
    T extends runtime.Types.Utils.Record<'select', any>
      ? T['select'] extends true
        ? number
        : Prisma.GetScalarType<T['select'], EventRecurrenceLinkCountAggregateOutputType>
      : number
  >

  /**
   * Allows you to perform aggregations operations on a EventRecurrenceLink.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {EventRecurrenceLinkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
   * @example
   * // Ordered by age ascending
   * // Where email contains prisma.io
   * // Limited to the 10 users
   * const aggregations = await prisma.user.aggregate({
   *   _avg: {
   *     age: true,
   *   },
   *   where: {
   *     email: {
   *       contains: "prisma.io",
   *     },
   *   },
   *   orderBy: {
   *     age: "asc",
   *   },
   *   take: 10,
   * })
  **/
  aggregate<T extends EventRecurrenceLinkAggregateArgs>(args: Prisma.Subset<T, EventRecurrenceLinkAggregateArgs>): Prisma.PrismaPromise<GetEventRecurrenceLinkAggregateType<T>>

  /**
   * Group by EventRecurrenceLink.
   * Note, that providing `undefined` is treated as the value not being there.
   * Read more here: https://pris.ly/d/null-undefined
   * @param {EventRecurrenceLinkGroupByArgs} args - Group by arguments.
   * @example
   * // Group by city, order by createdAt, get count
   * const result = await prisma.user.groupBy({
   *   by: ['city', 'createdAt'],
   *   orderBy: {
   *     createdAt: true
   *   },
   *   _count: {
   *     _all: true
   *   },
   * })
   * 
  **/
  groupBy<
    T extends EventRecurrenceLinkGroupByArgs,
    HasSelectOrTake extends Prisma.Or<
      Prisma.Extends<'skip', Prisma.Keys<T>>,
      Prisma.Extends<'take', Prisma.Keys<T>>
    >,
    OrderByArg extends Prisma.True extends HasSelectOrTake
      ? { orderBy: EventRecurrenceLinkGroupByArgs['orderBy'] }
      : { orderBy?: EventRecurrenceLinkGroupByArgs['orderBy'] },
    OrderFields extends Prisma.ExcludeUnderscoreKeys<Prisma.Keys<Prisma.MaybeTupleToUnion<T['orderBy']>>>,
    ByFields extends Prisma.MaybeTupleToUnion<T['by']>,
    ByValid extends Prisma.Has<ByFields, OrderFields>,
    HavingFields extends Prisma.GetHavingFields<T['having']>,
    HavingValid extends Prisma.Has<ByFields, HavingFields>,
    ByEmpty extends T['by'] extends never[] ? Prisma.True : Prisma.False,
    InputErrors extends ByEmpty extends Prisma.True
    ? `Error: "by" must not be empty.`
    : HavingValid extends Prisma.False
    ? {
        [P in HavingFields]: P extends ByFields
          ? never
          : P extends string
          ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
          : [
              Error,
              'Field ',
              P,
              ` in "having" needs to be provided in "by"`,
            ]
      }[HavingFields]
    : 'take' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "take", you also need to provide "orderBy"'
    : 'skip' extends Prisma.Keys<T>
    ? 'orderBy' extends Prisma.Keys<T>
      ? ByValid extends Prisma.True
        ? {}
        : {
            [P in OrderFields]: P extends ByFields
              ? never
              : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
          }[OrderFields]
      : 'Error: If you provide "skip", you also need to provide "orderBy"'
    : ByValid extends Prisma.True
    ? {}
    : {
        [P in OrderFields]: P extends ByFields
          ? never
          : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
      }[OrderFields]
  >(args: Prisma.SubsetIntersection<T, EventRecurrenceLinkGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEventRecurrenceLinkGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
/**
 * Fields of the EventRecurrenceLink model
 */
readonly fields: EventRecurrenceLinkFieldRefs;
}

/**
 * The delegate class that acts as a "Promise-like" for EventRecurrenceLink.
 * Why is this prefixed with `Prisma__`?
 * Because we want to prevent naming conflicts as mentioned in
 * https://github.com/prisma/prisma-client-js/issues/707
 */
export interface Prisma__EventRecurrenceLinkClient<T, Null = never, ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
  readonly [Symbol.toStringTag]: "PrismaPromise"
  event<T extends Prisma.EventDefaultArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.EventDefaultArgs<ExtArgs>>): Prisma.Prisma__EventClient<runtime.Types.Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
  recurrence<T extends Prisma.EventRecurrenceDefaultArgs<ExtArgs> = {}>(args?: Prisma.Subset<T, Prisma.EventRecurrenceDefaultArgs<ExtArgs>>): Prisma.Prisma__EventRecurrenceClient<runtime.Types.Result.GetResult<Prisma.$EventRecurrencePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
  /**
   * Attaches callbacks for the resolution and/or rejection of the Promise.
   * @param onfulfilled The callback to execute when the Promise is resolved.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of which ever callback is executed.
   */
  then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): runtime.Types.Utils.JsPromise<TResult1 | TResult2>
  /**
   * Attaches a callback for only the rejection of the Promise.
   * @param onrejected The callback to execute when the Promise is rejected.
   * @returns A Promise for the completion of the callback.
   */
  catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): runtime.Types.Utils.JsPromise<T | TResult>
  /**
   * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
   * resolved value cannot be modified from the callback.
   * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
   * @returns A Promise for the completion of the callback.
   */
  finally(onfinally?: (() => void) | undefined | null): runtime.Types.Utils.JsPromise<T>
}




/**
 * Fields of the EventRecurrenceLink model
 */
export interface EventRecurrenceLinkFieldRefs {
  readonly event_id: Prisma.FieldRef<"EventRecurrenceLink", 'String'>
  readonly recurrence_id: Prisma.FieldRef<"EventRecurrenceLink", 'String'>
}
    

// Custom InputTypes
/**
 * EventRecurrenceLink findUnique
 */
export type EventRecurrenceLinkFindUniqueArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the EventRecurrenceLink
   */
  select?: Prisma.EventRecurrenceLinkSelect<ExtArgs> | null
  /**
   * Omit specific fields from the EventRecurrenceLink
   */
  omit?: Prisma.EventRecurrenceLinkOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.EventRecurrenceLinkInclude<ExtArgs> | null
  /**
   * Filter, which EventRecurrenceLink to fetch.
   */
  where: Prisma.EventRecurrenceLinkWhereUniqueInput
}

/**
 * EventRecurrenceLink findUniqueOrThrow
 */
export type EventRecurrenceLinkFindUniqueOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the EventRecurrenceLink
   */
  select?: Prisma.EventRecurrenceLinkSelect<ExtArgs> | null
  /**
   * Omit specific fields from the EventRecurrenceLink
   */
  omit?: Prisma.EventRecurrenceLinkOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.EventRecurrenceLinkInclude<ExtArgs> | null
  /**
   * Filter, which EventRecurrenceLink to fetch.
   */
  where: Prisma.EventRecurrenceLinkWhereUniqueInput
}

/**
 * EventRecurrenceLink findFirst
 */
export type EventRecurrenceLinkFindFirstArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the EventRecurrenceLink
   */
  select?: Prisma.EventRecurrenceLinkSelect<ExtArgs> | null
  /**
   * Omit specific fields from the EventRecurrenceLink
   */
  omit?: Prisma.EventRecurrenceLinkOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.EventRecurrenceLinkInclude<ExtArgs> | null
  /**
   * Filter, which EventRecurrenceLink to fetch.
   */
  where?: Prisma.EventRecurrenceLinkWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of EventRecurrenceLinks to fetch.
   */
  orderBy?: Prisma.EventRecurrenceLinkOrderByWithRelationInput | Prisma.EventRecurrenceLinkOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for EventRecurrenceLinks.
   */
  cursor?: Prisma.EventRecurrenceLinkWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` EventRecurrenceLinks from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` EventRecurrenceLinks.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of EventRecurrenceLinks.
   */
  distinct?: Prisma.EventRecurrenceLinkScalarFieldEnum | Prisma.EventRecurrenceLinkScalarFieldEnum[]
}

/**
 * EventRecurrenceLink findFirstOrThrow
 */
export type EventRecurrenceLinkFindFirstOrThrowArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the EventRecurrenceLink
   */
  select?: Prisma.EventRecurrenceLinkSelect<ExtArgs> | null
  /**
   * Omit specific fields from the EventRecurrenceLink
   */
  omit?: Prisma.EventRecurrenceLinkOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.EventRecurrenceLinkInclude<ExtArgs> | null
  /**
   * Filter, which EventRecurrenceLink to fetch.
   */
  where?: Prisma.EventRecurrenceLinkWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of EventRecurrenceLinks to fetch.
   */
  orderBy?: Prisma.EventRecurrenceLinkOrderByWithRelationInput | Prisma.EventRecurrenceLinkOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for searching for EventRecurrenceLinks.
   */
  cursor?: Prisma.EventRecurrenceLinkWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` EventRecurrenceLinks from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` EventRecurrenceLinks.
   */
  skip?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
   * 
   * Filter by unique combinations of EventRecurrenceLinks.
   */
  distinct?: Prisma.EventRecurrenceLinkScalarFieldEnum | Prisma.EventRecurrenceLinkScalarFieldEnum[]
}

/**
 * EventRecurrenceLink findMany
 */
export type EventRecurrenceLinkFindManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the EventRecurrenceLink
   */
  select?: Prisma.EventRecurrenceLinkSelect<ExtArgs> | null
  /**
   * Omit specific fields from the EventRecurrenceLink
   */
  omit?: Prisma.EventRecurrenceLinkOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.EventRecurrenceLinkInclude<ExtArgs> | null
  /**
   * Filter, which EventRecurrenceLinks to fetch.
   */
  where?: Prisma.EventRecurrenceLinkWhereInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
   * 
   * Determine the order of EventRecurrenceLinks to fetch.
   */
  orderBy?: Prisma.EventRecurrenceLinkOrderByWithRelationInput | Prisma.EventRecurrenceLinkOrderByWithRelationInput[]
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
   * 
   * Sets the position for listing EventRecurrenceLinks.
   */
  cursor?: Prisma.EventRecurrenceLinkWhereUniqueInput
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Take `Â±n` EventRecurrenceLinks from the position of the cursor.
   */
  take?: number
  /**
   * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
   * 
   * Skip the first `n` EventRecurrenceLinks.
   */
  skip?: number
  distinct?: Prisma.EventRecurrenceLinkScalarFieldEnum | Prisma.EventRecurrenceLinkScalarFieldEnum[]
}

/**
 * EventRecurrenceLink create
 */
export type EventRecurrenceLinkCreateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the EventRecurrenceLink
   */
  select?: Prisma.EventRecurrenceLinkSelect<ExtArgs> | null
  /**
   * Omit specific fields from the EventRecurrenceLink
   */
  omit?: Prisma.EventRecurrenceLinkOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.EventRecurrenceLinkInclude<ExtArgs> | null
  /**
   * The data needed to create a EventRecurrenceLink.
   */
  data: Prisma.XOR<Prisma.EventRecurrenceLinkCreateInput, Prisma.EventRecurrenceLinkUncheckedCreateInput>
}

/**
 * EventRecurrenceLink createMany
 */
export type EventRecurrenceLinkCreateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to create many EventRecurrenceLinks.
   */
  data: Prisma.EventRecurrenceLinkCreateManyInput | Prisma.EventRecurrenceLinkCreateManyInput[]
}

/**
 * EventRecurrenceLink createManyAndReturn
 */
export type EventRecurrenceLinkCreateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the EventRecurrenceLink
   */
  select?: Prisma.EventRecurrenceLinkSelectCreateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the EventRecurrenceLink
   */
  omit?: Prisma.EventRecurrenceLinkOmit<ExtArgs> | null
  /**
   * The data used to create many EventRecurrenceLinks.
   */
  data: Prisma.EventRecurrenceLinkCreateManyInput | Prisma.EventRecurrenceLinkCreateManyInput[]
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.EventRecurrenceLinkIncludeCreateManyAndReturn<ExtArgs> | null
}

/**
 * EventRecurrenceLink update
 */
export type EventRecurrenceLinkUpdateArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the EventRecurrenceLink
   */
  select?: Prisma.EventRecurrenceLinkSelect<ExtArgs> | null
  /**
   * Omit specific fields from the EventRecurrenceLink
   */
  omit?: Prisma.EventRecurrenceLinkOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.EventRecurrenceLinkInclude<ExtArgs> | null
  /**
   * The data needed to update a EventRecurrenceLink.
   */
  data: Prisma.XOR<Prisma.EventRecurrenceLinkUpdateInput, Prisma.EventRecurrenceLinkUncheckedUpdateInput>
  /**
   * Choose, which EventRecurrenceLink to update.
   */
  where: Prisma.EventRecurrenceLinkWhereUniqueInput
}

/**
 * EventRecurrenceLink updateMany
 */
export type EventRecurrenceLinkUpdateManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * The data used to update EventRecurrenceLinks.
   */
  data: Prisma.XOR<Prisma.EventRecurrenceLinkUpdateManyMutationInput, Prisma.EventRecurrenceLinkUncheckedUpdateManyInput>
  /**
   * Filter which EventRecurrenceLinks to update
   */
  where?: Prisma.EventRecurrenceLinkWhereInput
  /**
   * Limit how many EventRecurrenceLinks to update.
   */
  limit?: number
}

/**
 * EventRecurrenceLink updateManyAndReturn
 */
export type EventRecurrenceLinkUpdateManyAndReturnArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the EventRecurrenceLink
   */
  select?: Prisma.EventRecurrenceLinkSelectUpdateManyAndReturn<ExtArgs> | null
  /**
   * Omit specific fields from the EventRecurrenceLink
   */
  omit?: Prisma.EventRecurrenceLinkOmit<ExtArgs> | null
  /**
   * The data used to update EventRecurrenceLinks.
   */
  data: Prisma.XOR<Prisma.EventRecurrenceLinkUpdateManyMutationInput, Prisma.EventRecurrenceLinkUncheckedUpdateManyInput>
  /**
   * Filter which EventRecurrenceLinks to update
   */
  where?: Prisma.EventRecurrenceLinkWhereInput
  /**
   * Limit how many EventRecurrenceLinks to update.
   */
  limit?: number
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.EventRecurrenceLinkIncludeUpdateManyAndReturn<ExtArgs> | null
}

/**
 * EventRecurrenceLink upsert
 */
export type EventRecurrenceLinkUpsertArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the EventRecurrenceLink
   */
  select?: Prisma.EventRecurrenceLinkSelect<ExtArgs> | null
  /**
   * Omit specific fields from the EventRecurrenceLink
   */
  omit?: Prisma.EventRecurrenceLinkOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.EventRecurrenceLinkInclude<ExtArgs> | null
  /**
   * The filter to search for the EventRecurrenceLink to update in case it exists.
   */
  where: Prisma.EventRecurrenceLinkWhereUniqueInput
  /**
   * In case the EventRecurrenceLink found by the `where` argument doesn't exist, create a new EventRecurrenceLink with this data.
   */
  create: Prisma.XOR<Prisma.EventRecurrenceLinkCreateInput, Prisma.EventRecurrenceLinkUncheckedCreateInput>
  /**
   * In case the EventRecurrenceLink was found with the provided `where` argument, update it with this data.
   */
  update: Prisma.XOR<Prisma.EventRecurrenceLinkUpdateInput, Prisma.EventRecurrenceLinkUncheckedUpdateInput>
}

/**
 * EventRecurrenceLink delete
 */
export type EventRecurrenceLinkDeleteArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the EventRecurrenceLink
   */
  select?: Prisma.EventRecurrenceLinkSelect<ExtArgs> | null
  /**
   * Omit specific fields from the EventRecurrenceLink
   */
  omit?: Prisma.EventRecurrenceLinkOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.EventRecurrenceLinkInclude<ExtArgs> | null
  /**
   * Filter which EventRecurrenceLink to delete.
   */
  where: Prisma.EventRecurrenceLinkWhereUniqueInput
}

/**
 * EventRecurrenceLink deleteMany
 */
export type EventRecurrenceLinkDeleteManyArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Filter which EventRecurrenceLinks to delete
   */
  where?: Prisma.EventRecurrenceLinkWhereInput
  /**
   * Limit how many EventRecurrenceLinks to delete.
   */
  limit?: number
}

/**
 * EventRecurrenceLink without action
 */
export type EventRecurrenceLinkDefaultArgs<ExtArgs extends runtime.Types.Extensions.InternalArgs = runtime.Types.Extensions.DefaultArgs> = {
  /**
   * Select specific fields to fetch from the EventRecurrenceLink
   */
  select?: Prisma.EventRecurrenceLinkSelect<ExtArgs> | null
  /**
   * Omit specific fields from the EventRecurrenceLink
   */
  omit?: Prisma.EventRecurrenceLinkOmit<ExtArgs> | null
  /**
   * Choose, which related nodes to fetch as well
   */
  include?: Prisma.EventRecurrenceLinkInclude<ExtArgs> | null
}
